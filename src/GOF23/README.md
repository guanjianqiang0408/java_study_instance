## GOF23(Gang of Four 23) --> 23种设计模式
LINK: https://zhuanlan.zhihu.com/p/447547008#:~:text=25000字详解23种设计模式（多图+代码）


## 设计原则
1. 面向接口编程，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。
2. 职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。
3. 对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。

## 设计模式

- 创建者模式
  - 工厂模式
    ```
        本质：
        实例化对象不使用new，用工厂方法创建对象
        使用工厂统一管理对象的创建，将调用者跟实现类解耦
    ```
    - 简单工厂模式
    ```
        实例参见 GOF23.createModule.SampleFactory.java
        优点： 好理解，易操作
        缺点： 类创建依赖于工厂类，拓展会修改工厂类内容，违反了设计模式中的OCP开闭原则（对拓展开放，对修改关闭）
    ```
    
    - 工厂方法
    ```
        实例参见： GOF23.createModule.FactoryMethod.java
        对简单工厂模式的改进，使用一个工厂接口，创建多个工厂类，每个工厂创建对应的对象
    
        工厂方法模式，创建一个工厂接口和创建多个工厂实现类，一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。
        有利于代码的维护和扩展
    ```
    
    - 抽象工厂
    ```
        实例参见GOF23.AbstractFactoryModule.java
        围绕一个超级工厂创建其他工厂，每个工厂可以生产不同类型的产品
    
        抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。
        从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。
        将工厂抽象成两层，抽象工厂 和 具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂集合， 更利于代码的维护和扩展。
    ```
    
    - 单例模式（参考：https://zhuanlan.zhihu.com/p/150004430）
      ```
        实例参见GOF23.createModule.SimpleInstance.java
      
        单例类只能有一个实例。
        单例类必须自己创建自己的唯一实例。
        单例类必须给所有其他对象提供这一实例
      
        优点：

        在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
        避免对资源的多重占用（比如写文件操作）。
        缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。
        
        使用场景：
        
        要求生产唯一序列号。
        WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。
        创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。
        注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。
      ```
      
      - 建造者模式（参考： https://zhuanlan.zhihu.com/p/492862691#:~:text=%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%201%20%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Builder%20Pattern%EF%BC%89%20%E5%8F%88%E5%8F%AB%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%98%AF%E4%B8%80%E7%A7%8D%E5%AF%B9%E8%B1%A1%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%BC%8F%E3%80%82%20%E5%AE%83%E5%8F%AF%E4%BB%A5,%E5%B0%86%E5%A4%8D%E6%9D%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BB%BA%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1%E5%87%BA%E6%9D%A5%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%88%AB%EF%BC%89%EF%BC%8C%E4%BD%BF%E8%BF%99%E4%B8%AA%E6%8A%BD%E8%B1%A1%E8%BF%87%E7%A8%8B%E7%9A%84%E4%B8%8D%E5%90%8C%E5%AE%9E%E7%8E%B0%E6%96%B9%20%E6%B3%95%E5%8F%AF%E4%BB%A5%E6%9E%84%E9%80%A0%E5%87%BA%E4%B8%8D%E5%90%8C%E8%A1%A8%E7%8E%B0%EF%BC%88%E5%B1%9E%E6%80%A7%EF%BC%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E3%80%82%202%20%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%20%E6%98%AF%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%A4%8D%E6%9D%82%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%AE%83%E5%85%81%E8%AE%B8%E7%94%A8%E6%88%B7%E5%8F%AA%E9%80%9A%E8%BF%87%E6%8C%87%E5%AE%9A%E5%A4%8D%E6%9D%82%E5%AF%B9%E8%B1%A1%20%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%86%85%E5%AE%B9%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%9E%84%E5%BB%BA%E5%AE%83%E4%BB%AC%EF%BC%8C%E7%94%A8%E6%88%B7%E4%B8%8D%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E5%86%85%E9%83%A8%E7%9A%84%E5%85%B7%E4%BD%93%E6%9E%84%E5%BB%BA%E7%BB%86%E8%8A%82%E3%80%82）
        ```
          实例参见GOF23.createModule.BuilderModule.java
          一、基本介绍
          建造者模式（Builder Pattern） 又叫生成器模式，是一种对象构建模式。它可以 将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方 法可以构造出不同表现（属性）的对象。
          建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象 的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。
          
          二、建造者模式的四个角色
          Product（产品角色）： 一个具体的产品对象。
          Builder（抽象建造者）： 创建一个Product对象的各个部件指定的 接口/抽象类。
          ConcreteBuilder（具体建造者）： 实现接口，构建和装配各个部件。
          Director（指挥者）： 构建一个使用Builder接口的对象。它主要是用于创建一个 复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是： 负责控制产品对象的生产过程。
          
          盖房项目需求
        
          需要建房子：这一过程为打桩、砌墙、封顶
          房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是 要求不要相同的.
          请编写程序，完成需求
          通过过建造者模式进行实现。
        
          建造者模式的注意事项和细节
            1. 客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解 耦，使得相同的创建过程可以创建不同的产品对象
            2. 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替 换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同 的产品对象
            3. 以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法 中，使得创建过程更加清晰，也更方便使用程序来控制创建过程
            4. 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程， 系统扩展方便，符合 “开闭原则”
            5. 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间 的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
            6. 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化， 导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.
            7. 抽象工厂模式VS建造者模式 抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不 同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品 由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要 目的是通过组装零配件而产生一个新产品
        ```